#!/usr/bin/env bash
#
#  sd -- wrapper executable for the user's `s`cripts `d`irectory.
#
#  At a high-level, its goal is to dispatch `argv` to a file-system tree with
#  executable files (scripts) at the leaves, for instance:
#
#  $ sd foo bar name ...    # runs `$dir/foo/bar/name ...`

set -euo pipefail

[ -n "${SD_ROOT+1}" ] || { echo '$SD_ROOT not set' >&2; exit 1; }
dir="$SD_ROOT"

# Scripts get access to the root directory via an environment variable:
export SD_ROOT="$dir"

while [[ $# > 0 ]]; do
    command="$1"
    command_path="$dir/$command"
    shift
    if [[ -d "$command_path" ]]; then
        dir="$command_path"
    elif [[ -f "$command_path" ]]; then
        if [[ -x "$command_path" ]]; then
            "$command_path" "$@"
            exit 0
        else
            read -n1 -p "The '$command' script is not executable. Shall I make it so? [Y/n] " response
            echo
            case $response in
                [Nn]* ) echo "Exiting"; exit 1 ;;
                * ) chmod +x "$command_path"; "$command_path" "$@"; exit 0 ;;
            esac
        fi
    else
        echo "Not found: $command_path" >&2
        exit 1
    fi
done

dir_real="$(realpath $dir)"

if [[ -e "$dir.help" ]]; then
    cat "$dir.help"
    echo
else
    root_real=$(realpath "$SD_ROOT")
    script_command="sd$(echo ${dir_real#"${root_real}"} | tr '/' ' ') ..." # Strip $dir_real prefix & replace '/' with ' '
    echo "'$script_command' commands:"
    echo
fi

no_commands=1

# Get the maximum length of any file-name in this directory (for printing later):
longest_script_path_length="$(find "$dir" -type f | awk '{ print length }' | sort -nr | head -n 1)"
dir_real="$(realpath $dir)"
script_dir_path_length="$(echo $dir_real | awk '{ print length }')"
padding=$(( $longest_script_path_length - $script_dir_path_length - 1 )) # -1 for the file separator

for file in $(find "$dir" -mindepth 1 -type f | sort); do
    script_basename="$(basename $file)"
    script_command="$(echo ${file#"${dir_real}/"} | tr '/' ' ')" # Strip $dir_real prefix & replace '/' with ' '
    help=$(grep --max-count=1 -oP "$script_basename -- \K.*$" $file || echo "(couldn't read help text)")
    printf "%-${padding}s  --  %s\n" "$script_command" "$help"
    no_commands=0
done

if [[ "$no_commands" -eq 1 ]]; then
    echo "(no subcommands found)"
fi

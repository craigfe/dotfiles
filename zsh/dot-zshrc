#!/bin/zsh

# if [ "$TMUX" = "" ]; then
#  	if ! tmux info &>/dev/null; then
#  		# No tmux server started yet – drop straight into a shell
#  		tmux new-session
#  	else
#  		while true; do
# 			rand_suffix="$(openssl rand -hex 3)"
# 	 		choose_session="choose-${rand_suffix}"
#
#  			tmux new-session -s "${choose_session}" \; \
#  				set-option destroy-unattached on \; \
#  				choose-tree \
#  				-F "(#{t:window_activity})#{?session_attached, (attached),}" \
#  				-f "#{==:0,#{m:choose-*,#{session_name}}}" \
#  				-t "${choose_session}" -s -O time -r
#
#  			tmux kill-session -t "${choose_session}"
#  		done
#  	fi
# fi

# Source secrets (API keys etc.) from a file not tracked in git
[ -f ~/.secrets/env.sh ] && source ~/.secrets/env.sh

export MONZO_AUTH_ENABLE_VPNLESS=true
export BRING_YOUR_OWN_GPG_AGENT=1
export LANG=en_GB.UTF-8
[[ -z "$TMUX" ]] && export TERM=xterm-256color

# Configure history
HISTFILE="$HOME/.zsh_history"
HISTSIZE=10000000
SAVEHIST=10000000

setopt EXTENDED_HISTORY          # Write the history file in the ":start:elapsed;command" format.
setopt INC_APPEND_HISTORY        # Write to the history file immediately, not when the shell exits.
setopt SHARE_HISTORY             # Share history between all sessions.
setopt HIST_EXPIRE_DUPS_FIRST    # Expire duplicate entries first when trimming history.
setopt HIST_VERIFY               # Don't execute immediately upon history expansion.
setopt AUTO_PUSHD
setopt APPEND_HISTORY

export PATH="$HOME/.local/bin:$HOME/.scripts:$PATH:/opt/homebrew/bin:$HOME/.yarn/bin"

COMPLETION_WAITING_DOTS="false"

# Don't mark untracked files as dirty
DISABLE_UNTRACKED_FILES_DIRTY="true"

# Oh My Zsh configuration
export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME="craigfe"

plugins=(git vi-mode ssh-agent)

source $ZSH/oh-my-zsh.sh

source $HOME/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
source $HOME/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
source $HOME/.aliases
[ -f $HOME/.shortcuts/out/shell ] && source $HOME/.shortcuts/out/shell

# User configuration

# Preferred editor for local and remote sessions
if [[ -n $SSH_CONNECTION ]]; then
  export EDITOR='nvim'
else
  export EDITOR='nvim'
fi

PROMPT_EOL_MARK=" •"

# Use the Vi navigation keys in menu completion
zstyle ':completion:*' menu select
zmodload zsh/complist

bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history

bindkey '^[[[SE' autosuggest-execute

bindkey -s '^g' 'projectgoto\n'

# Jump (https://github.com/gsamokovarov/jump)
eval "$(jump shell)"

fh() {
    print -z $(history |\
                   fzf --no-sort --tac |\
                   sed -E 's/ *[0-9]*\*? *//; s/\\/\\\\/g')
}

ch() {
    local cols sep google_history open
    cols=$(( COLUMNS / 3 ))
    sep='{::}'

    if [ "$(uname)" = "Darwin" ]; then
        google_history="$HOME/Library/Application Support/Google/Chrome/Default/History"
        open=open
    else
        google_history="$HOME/.config/google-chrome/Default/History"
        open=xdg-open
    fi
    cp -f "$google_history" /tmp/h
    sqlite3 -separator $sep /tmp/h \
            "select substr(title, 1, $cols), url
     from urls order by last_visit_time desc" |
        awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
        fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open > /dev/null 2> /dev/null
}

# BRING_YOUR_OWN_GPG_AGENT=1
[ -f $HOME/src/github.com/monzo/starter-pack/zshrc ] && source $HOME/src/github.com/monzo/starter-pack/zshrc

# Go configuration
export GOTEST_SKIPNOTESTS=true

# Terraform
export TFENV_ARCH=arm64 # No `arm64` version shipped pre-1.0.2

autoload -U edit-command-line
zle -N edit-command-line
bindkey -M menuselect 'v' edit-command-line

export PATH="/opt/homebrew/opt/openjdk@11/bin:$PATH"

# The next line updates PATH for the Google Cloud SDK.
if [ -f '/Users/craigferguson/google-cloud-sdk/path.zsh.inc' ]; then . '/Users/craigferguson/google-cloud-sdk/path.zsh.inc'; fi

# The next line enables shell command completion for gcloud.
if [ -f '/Users/craigferguson/google-cloud-sdk/completion.zsh.inc' ]; then . '/Users/craigferguson/google-cloud-sdk/completion.zsh.inc'; fi
export USE_GKE_GCLOUD_AUTH_PLUGIN=True

export JAVA_HOME=$(/usr/libexec/java_home -v 19)

adblogin() {
  droid deeplink $(£ -e s101 "api get /nonprod.test-user-email-log/magic-link recipient_email==\"$1\"" | jq .link -r);
}

# Add RVM to PATH for scripting. Make sure this is the last PATH variable change.
export PATH="$PATH:$HOME/.rvm/bin"

export PATH="$PATH:/opt/homebrew/Cellar/janet/1.27.0/bin"
export EXPECT_DIFF_COMMAND="delta --file-style=omit --hunk-header-style=omit --line-numbers"
export EXPECT_COLOR="always"

_monzo_cli_completions() {
  # Capture the current words and cursor position
  local wordsarr cword
  wordsarr=("${words[@]}")
  cword=$((CURRENT - 1))

  # Call your Go binary to generate completions
  local completions
  completions=($(/Users/craigferguson/src/github.com/monzo/wearedev/cli-completion "${wordsarr[*]}" "$cword"))

  _describe 'values' completions
  compadd -S '' "${completions[@]}"
}

compdef _monzo_cli_completions ££

# Activate Mise
eval "$(mise activate zsh)"

worktree() {
	# This shell function is provided by Monzo's Worktree tool.
	# It wraps the 'worktree' command to change the shell's working
	# directory.
	#
	# github.com/monzo/wearedev/tools/worktree

	if [[ "$1" == "path" ]] && ! [ -x "$(command -v worktree)" ]; then
		# Worktree should be installed by Monzo Developer Tools but I
		# imagine it's possible to depend on 'worktree path wearedev'
		# before it's installed. This path is hard coded to the path
		# set by the engineering onboarding scripts, and attempts to
		# use the project argument, or "wearedev" if none is given.
		echo "$GOPATH/src/github.com/monzo/${2:-wearedev}"
		return $?
	fi

    case "$1" in
        path|shell)
            # These commands never require the tmp file so don't bother creating it.
            # Especially a concern for the path command as it's used so frequently.
            command worktree "$@"
            return $?;;
    esac

    local tempfile=$(mktemp "${TMPDIR:-/tmp/}worktree.XXXXXX")
    command worktree "$@" --tmp-output="$tempfile"
    local exit_code=$?

    if [[ $exit_code -eq 0 && -e $tempfile ]]; then
        local worktree_path=$(command head -1 "$tempfile")
        cd "$worktree_path"
    fi

    return $exit_code
}
